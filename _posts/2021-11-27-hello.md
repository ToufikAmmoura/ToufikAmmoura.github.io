---
layout: post
title:  "x86 32 bit"
date:   2021-11-27 22:56:00 +0100
categories: jekyll update
---

A large list of instructions, a stack, finite memory, and a handfull of 32- 16- and 8-bit register. Components that make running programs possible but are used in various ways throughout the different levels of language. Registers do not even come up in the mind when coding a Python script since the interpreter is going to worry about that, but making a step in Assembly without one is essentially impossible. Needless to say this was the whole point behind designing new languages because programmers could not be bothered to think about all the different details going on in the background. 

Yet, this is exactly the experience we ,the programmers, should be seeking. In order to be appreciative of the weight that has been lifted off our shoulders, we must try out a low level language such as x86 to get aware of the lack of abstraction. Diving deep in the ancient scriptures about computer architectures and the way bits and bytes flow through the computer.

Writing programs with x86 required different thinking than what I was used to. Especially with the use of conditional jumps which makes thinking about the flow of the program a whole different kind of task. But be aware of going back to C/C++ after writing in x86 because it took me a day to readjust my way of thinking again. The reason being that in assembly, a lot of the time you will be using `jump` to control the flow of the program. This is not a problem here and if you do it right the code will be readable and nobody would call it spaghetti-code. 

In higher level languages there is no love for the `jump` command though. Using it is considered a sin and we should keep it that way too. But since I was accustomed to using conditional jumps to get where I wanted to go this was no longer allowed in C, so I needed to stop using assembly flow-patters in C programming.

The way I experienced this was first coding the tictactoe game in x86 and later in C. Seeing one working game in two different languages gives you insight in how different the flow patters and way of working are in the two languages.

to be continued...

```nasm

.text
main:
    mov     eax, 10
    add     eax, 20
    push    eax

```

